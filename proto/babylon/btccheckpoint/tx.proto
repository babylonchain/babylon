syntax = "proto3";
package babylon.btccheckpoint.v1;

import "gogoproto/gogo.proto";

// this line is used by starport scaffolding # proto/tx/import

option go_package = "github.com/babylonchain/babylon/x/btccheckpoint/types";

// Msg defines the Msg service.
service Msg {
  rpc InsertBTCSpvProof(MsgInsertBTCSpvProof) returns (MsgInsertBTCSpvProofResponse);
}

// Consider we have a Merkle tree with following structure:
//            ROOT
//           /    \
//      H1234      H5555
//     /     \       \
//   H12     H34      H55
//  /  \    /  \     /
// H1  H2  H3  H4  H5
// L1  L2  L3  L4  L5
// To prove L3 was part of ROOT we need:
// - btc_transaction_index = 2 which in binary is 010
// (where 0 means going left, 1 means going right in the tree)
// - merkle_nodes we'd have H4 || H12 || H5555
// By looking at 010 we would know that H4 is a right sibling,
// H12 is left, H5555 is right again.
message BTCSpvProof {
  // Valid bitcoin transaction containing OP_RETURN opcode.
  bytes btc_transaction = 1;
  // Index of transaction within the block. Index is needed to determine if
  // currently hashed node is left or right.
  uint32 btc_transaction_index = 2;
  // List of concatenated intermediate merkle tree nodes, without root node and leaf node
  // against which we calculate the proof.
  // Each node has 32 byte length.
  // Example proof can look like: 32_bytes_of_node1 || 32_bytes_of_node2 ||  32_bytes_of_node3
  // so the length of the proof will always be divisible by 32.
  bytes merkle_nodes = 3;
  // Valid btc header which confirms btc_transaction.
  // Should have exactly 80 bytes
  bytes confirming_btc_header = 4 [
    (gogoproto.customtype) = "github.com/babylonchain/babylon/types.BTCHeaderBytes"
  ];
}

message MsgInsertBTCSpvProof {
  string submitter = 1;
  repeated BTCSpvProof proofs = 2;
}

message MsgInsertBTCSpvProofResponse {}

// this line is used by starport scaffolding # proto/tx/message
