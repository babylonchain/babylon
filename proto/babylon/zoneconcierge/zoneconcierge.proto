syntax = "proto3";
package babylonchain.babylon.zoneconcierge;

option go_package = "github.com/babylonchain/babylon/x/zoneconcierge/types";

// IndexedHeader is the metadata of a CZ header
message IndexedHeader {
  // chain_id is the unique ID of the chain
  string chain_id = 1;
  // hash is the hash of this header
  bytes hash = 2;
  // height is the height of this header on CZ ledger
  // (hash, height) jointly provides the position of the header on CZ ledger
  uint64 height = 3;
  // babylon_block_height is the height of the Babylon block that includes this header
  uint64 babylon_block_height = 4;
  // babylon_tx_hash is the hash of the tx that includes this header
  // (babylon_block_height, babylon_tx_hash) jointly provides the position of the header on Babylon ledger
  bytes babylon_tx_hash = 5;
}

// Fork is a list of non-canonical `IndexedHeader`s at the same height.
// For example, assuming the following blockchain
// ```
// A <- B <- C <- D <- E
//            \ -- D1
//            \ -- D2
// ```
// Then the fork will be {[D1, D2]} where each item is in struct `IndexedBlock`.
// 
// Note that each `IndexedHeader` in the fork should have a valid quorum certificate. 
// Such forks exist since Babylon considers CZs might have dishonest majority.
// Also note that the IBC-Go implementation will only consider the first header in a fork valid, since
// the subsequent headers cannot be verified without knowing the validator set in the previous header.
message Fork {
  // blocks is the list of non-canonical indexed headers at the same height
  repeated IndexedHeader headers = 3;
}

// ChainInfo is the information of a CZ
message ChainInfo {
  // chain_id is the ID of the chain
  string chain_id = 1;
  // latest_header is the latest header in the canonical chain of CZ
  IndexedHeader latest_header = 2;
  // latest_fork is the latest fork, formed as a series of IndexedHeader (from low to high)
  Fork latest_fork = 3;
}
